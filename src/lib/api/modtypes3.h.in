    mark_nmarks
  };

  // fomus will pass the fomus_data object to `run' function if module_all,
  // a part object if module_bypart, and a meas object if module_bymeas
  enum module_iter_type {
    module_all = 0x0, // these groups can be combined (ex. by part & by voice)
    module_bypart = 0x1,
    module_bymeas = 0x2,
    module_bymeasgroups = 0x4,

    module_byvoice = 0x8, // everything else is either/or or neither
    module_bystaff = 0x10,

    module_nograce = 0x20,
    module_graceonly = 0x40,
    
    module_norests = 0x80,
    module_restsonly = 0x100,

    module_firsttied = 0x200, // combine these three, or none for all
    module_midtied = 0x400,
    module_lasttied = 0x800,

    module_noperc = 0x1000,
    module_perconly = 0x2000,

    module_noinvisible = 0x4000 // skip invisible notes (not rests)
  };
  
  // types and structs for defining module variables
  enum module_value_type {
    module_none, // used only for info queries, not by modules!
    
    module_bool, // for SETTING TYPE only, same as an int, only parsing is different
    module_int,
    module_float,
    module_rat,
    module_number, // for SETTING TYPE only, NOT a VALUE TYPE
    module_notesym, // for SETTING TYPE only
    module_string,
    module_stringnum, // for MARKS only--args can include both a string and a number
    
    module_list, // everything after this must be some kind of list! (for `freevalue' function to catch possible errors)
    module_list_nums, // for setting, must use more specific list type...
    module_list_strings,
    module_symmap_nums,
    module_symmap_strings,
    module_list_numlists,
    module_list_stringlists,
    module_symmap_numlists,
    module_symmap_stringlists,
    module_special
  };

  struct module_value;
  struct module_list {
    int n;
    struct module_value* vals;
  };
  union module_value_val {
    fomus_int i;
    fomus_float f;
    struct fomus_rat r;
    const char* s;
    struct module_list l;
  };
  struct module_value {
    enum module_value_type type; // the type
    union module_value_val val;
  };
  
  enum module_setting_loc {
    module_noloc, // used only for info queries, not by modules!
    module_locscore,
    module_locimport,
    module_locexport,
    module_locinst,
    module_locpercinst,
    module_locpartmap,
    module_locpart, // implies global
    module_locmeasdef,
    module_locstaff,
    module_locclef,
    module_locnote, // implies instpartmeas and global
  };
  
  // type for variable validation function
  typedef int (*module_valid_fun)(struct module_value val); // must return true/false and optionally set ERR string to error message
  
  // struct for registering a FOMUS variable
  struct module_setting {
    const char* name; // unique variable name, mandatory
    enum module_value_type type;
    const char* descdoc; // documentation string (can be NULL)
    const char* typedoc; // can be NULL
    struct module_value val; // default value
    enum module_setting_loc loc; // bit ORed allowed locations
    module_valid_fun valid; // can be NULL--this is usually the one to set
    int uselevel; // if other than 0 (often/always set), set to 1-3 (1=details like number of chars in tab space, 2=sometimes, 3=seldom used/expert)
  };

  struct module_mark {
    const char* name;
    enum module_value_type type; // none, numb, string or stringnumb
    unsigned int props;
    const char* doc;
  };

  typedef int (*valid_int)(fomus_int val);
  typedef int (*valid_rat)(struct fomus_rat val);
  typedef int (*valid_num)(struct module_value val);
  typedef int (*valid_string)(const char* val);
  typedef int (*valid_listint)(int n, fomus_int val);
  typedef int (*valid_listrat)(int n, struct fomus_rat val);
  typedef int (*valid_listnum)(int n, const struct module_value* val);
  typedef int (*valid_liststring)(int n, const char* val);
  typedef int (*valid_listval)(int n, struct module_value val);
  typedef int (*valid_mapint)(int n, const char* sym, fomus_int val);
  typedef int (*valid_maprat)(int n, const char* sym, struct fomus_rat val);
  typedef int (*valid_mapnum)(int n, const char* sym, const struct module_value* val);
  typedef int (*valid_mapstring)(int n, const char* sym, const char* val);
  typedef int (*valid_mapval)(int n, const char* sym, struct module_value val);

  enum module_bound {
    module_nobound,
    module_incl,
    module_excl
  };

  struct module_objlist {
    int n;
    module_obj* objs;
  };

  struct module_intslist {
    int n;
    const int* ints;
  };
  struct module_ratslist {
    int n;
    const struct fomus_rat* rats;
  };
  struct module_markslist {
    int n;
    const module_markobj* marks;
  };

  struct module_noteparts {
    struct fomus_rat note, acc1, acc2, oct;
  };
  struct module_keysigref {
    struct fomus_rat acc1, acc2;
  };
  
  typedef void (*modfun_init)();
  typedef void (*modfun_free)();
  typedef const char* (*modfun_initerr)();
  
  typedef void* (*modfun_newdata)(FOMUS f); // modcbacks.h
  typedef void (*modfun_freedata)(void* data);
  typedef const char* (*modfun_longname)();
  typedef const char* (*modfun_author)();
  typedef const char* (*modfun_doc)();
  typedef const char* (*modfun_err)(void* data);
  typedef enum module_type (*modfun_type)();
  typedef const char* (*modfun_engine)(void* m);
  typedef int (*modfun_getsetting)(int n, struct module_setting* set, int id);
  typedef int (*modfun_itertype)(); // returns module_iter_type as int
  typedef int (*modfun_priority)(); // modmod.h
  typedef void (*modfun_fillinterface)(void* moddata, void* iface);
  typedef int (*modfun_interfaceid)();
  typedef int (*modfun_sameinst)(module_obj a, module_obj b);  
  typedef void (*modfun_ready)();
  
  typedef const char* (*modinoutfun_getext)(int n); // modinout.h
  typedef const char* (*modinoutfun_getloadid)();
  typedef int (*modinfun_load)(FOMUS f, void* data, const char* fn, int isfile);
  typedef void (*modoutfun_write)(FOMUS f, void* data, const char* fn);
  typedef int (*modoutfun_ispre)();
  
  typedef void* (*engfun_getinterface)(void* engdata); // modengine.h
  typedef int (*engauxfun_interfaceid)();
  typedef void (*engfun_run)(void* data);
  
  typedef void (*auxfun_fillinterface)(void* iface);

  struct module_callbacks {
    modfun_init init_fun;
    modfun_free free_fun;
    modfun_initerr initerr_fun;
    modfun_newdata newdata_fun;
    modfun_freedata freedata_fun;
    modfun_longname longname_fun;
    modfun_author author_fun;
    modfun_doc doc_fun;
    modfun_err err_fun;
    modfun_type type_fun;
    modfun_engine engine_fun;
    modfun_getsetting getsetting_fun;
    modfun_itertype itertype_fun;
    modfun_priority priority_fun;
    modfun_fillinterface mod_fillinterface_fun;
    modfun_interfaceid mod_interfaceid_fun;
    modfun_sameinst sameinst_fun;
    modfun_ready ready_fun;
    modinoutfun_getext getext_fun;
    modinoutfun_getloadid getloadid_fun;
    modinfun_load load_fun;
    modoutfun_write write_fun;
    modoutfun_ispre ispre_fun;
    engfun_getinterface getinterface_fun;
    engauxfun_interfaceid engaux_interfaceid_fun;
    engfun_run run_fun;
    auxfun_fillinterface aux_fillinterface_fun;
  };
  
#ifdef __cplusplus
}
#endif

#endif
